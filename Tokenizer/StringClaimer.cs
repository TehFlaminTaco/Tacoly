using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Collections.Generic;

namespace Tacoly.Tokenizer;

using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Collections.Generic;

/// <summary>
/// A utility class that helps parsing a string by consuming substrings according to rules defined in <see cref="Claim"/>.
/// </summary>
public class StringClaimer
{
    public string File { get; private set; }

    /// <summary>
    /// Gets or sets the current index in the <see cref="Code"/> string.
    /// </summary>
    public int Index { get; set; } = 0;

    /// <summary>
    /// Gets the original code string passed to the <see cref="StringClaimer"/>.
    /// </summary>
    public string Code { get; private set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="StringClaimer"/> class with the specified code string.
    /// </summary>
    /// <param name="code">The code string to be parsed.</param>
    public StringClaimer(string code, string file)
    {
        Code = code;
        File = file;
    }

    /// <summary>
    /// Returns a new <see cref="Claim"/> object without consuming any characters.
    /// </summary>
    /// <returns>A new <see cref="Claim"/> object without consuming any characters.</returns>
    public Claim Flag()
    {
        return new Claim(this, null);
    }

    /// <summary>
    /// Consumes a substring from the current index using the specified <see cref="Regex"/> pattern and returns a new <see cref="Claim"/> object.
    /// </summary>
    /// <param name="regex">The <see cref="Regex"/> pattern to use for parsing.</param>
    /// <returns>A new <see cref="Claim"/> object containing the matched substring and its index in the code string.</returns>
    public Claim Claim(Regex regex, bool noSkip = false)
    {
        Debug.Assert(regex.ToString().StartsWith(@"\G"), @"Claim Regexes must be anchored (Begin with \G)");
        Debug.Assert(regex.Options.HasFlag(RegexOptions.Compiled), @"Claim Regexes should be compiled, as they're re-used heavily.");

        if (!noSkip)
            SkipWhitespace();

        Match match = regex.Match(Code, Index);
        if (match.Success)
            Index += match.Length;

        return new Claim(this, match);
    }

    // Note: This overload uses a cache to store compiled regex patterns for efficiency.
    /// <summary>
    /// Consumes a substring from the current index using the specified <paramref name="pattern"/> string and returns a new <see cref="Claim"/> object.
    /// </summary>
    /// <param name="pattern">The regex pattern string to use for parsing.</param>
    /// <returns>A new <see cref="Claim"/> object containing the matched substring and its index in the code string.</returns>
    public Claim Claim(string pattern, bool noSkip = false)
    {
        if (!_patternCache.TryGetValue(pattern, out Regex? regex))
            _patternCache[pattern] = regex = new Regex(@"\G(?:" + pattern + ")", RegexOptions.Compiled);

        return Claim(regex, noSkip);
    }

    public string Raw(Claim claim)
    {
        return Code[claim.Index..Index];
    }

    /// <summary>
    /// Skips any whitespace characters from the current index.
    /// </summary>
    public void SkipWhitespace()
    {
        Match match = WhitespaceRegex.Match(Code, Index);
        if (match.Success)
            Index += match.Length;
    }

    // Private members
    private static readonly Dictionary<string, Regex> _patternCache = new();

    private static readonly Regex WhitespaceRegex = new(@"\G(?://.*|/\*(?:.|\s)*(?:\*|$)/|\s+)+", RegexOptions.Compiled);

    public static readonly Regex Identifier = new(@"\G[a-zA-Z_]\w+", RegexOptions.Compiled);
}

/// <summary>
/// Represents a claimed substring in a <see cref="StringClaimer"/> object.
/// </summary>
public class Claim
{
    /// <summary>
    /// The StringClaimer that created this Claim.
    /// </summary>
    public StringClaimer Claimer { get; private set; }
    /// <summary>
    /// The Match object that was generated by the last regex matching.
    /// </summary>
    public Match? Match { get; private set; }
    /// <summary>
    /// Whether the last regex matching was successful or not.
    /// </summary>
    public bool Success { get; private set; }
    /// <summary>
    /// The position in the string that the last regex matching ended.
    /// </summary>
    public int Index { get; private set; }

    /// <summary>
    /// Constructor for creating a Claim object with a match.
    /// </summary>
    /// <param name="claimer">The StringClaimer that created this Claim.</param>
    /// <param name="match">The Match object that was generated by the last regex matching.</param>
    public Claim(StringClaimer claimer, Match? match)
    {
        Claimer = claimer;
        Match = match;
        Success = match is not null && match.Success;
        Index = match?.Index ?? claimer.Index;
    }

    /// <summary>
    /// Constructor for creating a failed Claim object.
    /// </summary>
    /// <param name="claimer">The StringClaimer that created this Claim.</param>
    private Claim(StringClaimer claimer)
    {
        Claimer = claimer;
        Match = null;
        Success = false;
        Index = claimer.Index;
    }

    /// <summary>
    /// Creates a new Claim object with Success set to true.
    /// </summary>
    /// <param name="claimer">The StringClaimer that created this Claim.</param>
    /// <returns>A new Claim object with Success set to true.</returns>
    public static Claim Flag(StringClaimer claimer)
    {
        return new Claim(claimer)
        {
            Success = true
        };
    }

    /// <summary>
    /// Changes the Success property of this Claim to false and sets the StringClaimer's Index property to the Index property of this Claim if the Claim's Success property is true.
    /// </summary>
    public void Fail()
    {
        if (Success)
        {
            Success = false;
            if (Claimer.Index > Index)
                Claimer.Index = Index;
        }
    }

}